use bb8;
use bb8::RunError;
use bb8_postgres;
use tokio_postgres::NoTls;
use crate::logic::models::*;
use uuid::Uuid;

pub type Pool = bb8::Pool<bb8_postgres::PostgresConnectionManager<NoTls>>;
pub type PError = tokio_postgres::Error;
pub type RError = RunError<PError>;

pub async fn save_user(pool: &Pool, user: DbUser) -> Result<DbUser, RError> {
    let connection = pool.get().await?;
    let query = "INSERT INTO users(id, chat, firstName, lastName, username) VALUES($1,$2,$3,$4,$5);";
    connection.execute(query, &[&user.id, &user.chat, &user.first_name, &user.last_name, &user.username]).await?;
    get_user(pool, &user.id).await
}

pub async fn get_user(pool: &Pool, id: &TelegramId) -> Result<DbUser, RError> {
    let connection = pool.get().await?;
    let query = "
    select id, chat, firstName, lastName, username
    from users
    WHERE id=$1;";
    let rows = connection.query(query, &[&id]).await?;
    let row = rows.get(0).unwrap();
    let user = DbUser {
        id: row.get(0),
        chat: row.get(1),
        first_name: row.get(2),
        last_name: row.get(3),
        username: row.get(4)
    };
    Ok(user)
}

pub async fn save_directory(pool: &Pool, user: DbUser, alias: &String, path: &String) -> Result<DownloadDirectory, RError> {
    let connection = pool.get().await?;
    let query = "INSERT INTO dirs(id, user_id, alias, path) VALUES($1,$2,$3,$4);";
    let dir_id = Uuid::new_v4();
    connection.execute(query, &[&dir_id.to_string(), &user.id, alias, path]).await?;
    get_directory_by_id(pool, &dir_id).await
}

async fn get_directory_by_id(pool: &Pool, id: &Uuid) -> Result<DownloadDirectory, RError> {
    let connection = pool.get().await?;
    let query = "
    select id, user_id, alias, path, ordinal
    from dirs
    WHERE id=$1;";
    let rows = connection.query(query, &[&id.to_string()]).await?;
    let row = rows.get(0).unwrap();
    let directory = DownloadDirectory {
        id: Uuid::parse_str(row.get(0)).expect("Uuid was generated by the system but failed to parse"),
        user_id: row.get(1),
        alias: row.get(2),
        path: row.get(3),
        ordinal: row.get(4),
    };
    Ok(directory)
}

// pub async fn get_directory(pool: &Pool, user: DbUser, ordinal: i32) -> Result<DownloadDirectory, RError> {

// }

// pub async fn get_directories(pool: &Pool, user: DbUser) -> Result<Vec<DownloadDirectory>, RError> {}
// pub async fn delete_directory(pool: &Pool, user: DbUser, ordinal: i32) -> Result<(), RError> {}

pub async fn add_task(pool: &Pool, user: DbUser, magnet: ShortMagnet, directory: &Uuid) -> Result<(), RError> {
    let connection = pool.get().await?;
    let query = "INSERT INTO tasks(id, user_id, magnet, directory, status) VALUES($1,$2,$3,$4,$5);";
    connection.query(query, &[&Uuid::new_v4().to_string(), &user.id, &String::from(magnet), &directory.to_string(), &TaskStatus::Created]).await?;
    Ok(())
}
// pub async fn update_task_status(pool: &Pool, user: DbUser, status: TaskStatus) -> Result<DownloadTask, RError> {}
// pub async fn update_task_status_description(pool: &Pool, user: DbUser, status: TaskStatus, description: &String) -> Result<DownloadTask, RError> {}