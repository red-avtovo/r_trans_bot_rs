use bb8;
use bb8::RunError;
use bb8_postgres;
use tokio_postgres::NoTls;
use tokio_postgres::row::Row;
use crate::logic::models::*;
use uuid::Uuid;
use crate::errors::DbError;

pub type Pool = bb8::Pool<bb8_postgres::PostgresConnectionManager<NoTls>>;
pub type PError = tokio_postgres::Error;
pub type RError = RunError<PError>;

pub async fn save_user(pool: &Pool, user: DbUser) -> Result<DbUser, DbError> {
    let connection = pool.get().await?;
    let query = "INSERT INTO users(id, chat, firstName, lastName, username, salt) VALUES($1,$2,$3,$4,$5);";
    connection.execute(query, &[&user.id, &user.chat, &user.first_name, &user.last_name, &user.username, &user.salt]).await?;
    get_user(pool, &user.id).await
}

pub async fn get_user(pool: &Pool, id: &TelegramId) -> Result<DbUser, DbError> {
    let connection = pool.get().await?;
    let query = "
    select id, chat, firstName, lastName, username, salt
    from users
    WHERE id=$1;";
    let rows = connection.query(query, &[&id]).await?;
    let row = rows.get(0).unwrap();
    let user = DbUser {
        id: row.get(0),
        chat: row.get(1),
        first_name: row.get(2),
        last_name: row.get(3),
        username: row.get(4),
        salt: row.get(5),
    };
    Ok(user)
}

pub async fn save_directory(pool: &Pool, user: &DbUser, alias: &String, path: &String) -> Result<DownloadDirectory, DbError> {
    let connection = pool.get().await?;
    let query = "INSERT INTO dirs(id, user_id, alias, path, ordinal) VALUES($1,$2,$3,$4,$5);";
    let dir_id = Uuid::new_v4();
    let next_ordinal = get_directory_next_ordinal(pool, user).await?;
    connection.execute(query, &[&dir_id.to_string(), &user.id, alias, path, &next_ordinal]).await?;
    get_directory_by_id(pool, &dir_id).await
}

async fn get_directory_by_id(pool: &Pool, id: &Uuid) -> Result<DownloadDirectory, DbError> {
    let connection = pool.get().await?;
    let query = "SELECT id, user_id, alias, path, ordinal FROM dirs WHERE id=$1;";
    let rows = connection.query(query, &[&id.to_string()]).await?;
    let row = rows.get(0).unwrap();
    Ok(DownloadDirectory::from_row(&row))
}

impl DownloadDirectory {
    fn from_row(row: &Row) -> Self {
        DownloadDirectory {
            id: Uuid::parse_str(row.get(0)).expect("Uuid was generated by the system but failed to parse"),
            user_id: row.get(1),
            alias: row.get(2),
            path: row.get(3),
            ordinal: row.get(4),
        }
    }
}

pub(crate) async fn get_directory_next_ordinal(pool: &Pool, user: &DbUser) -> Result<i32, DbError> {
    let connection = pool.get().await?;
    let query = "
    select max(ordinal)
    from dirs
    WHERE user_id=$1
    GROUP BY user_id;";
    let rows = connection.query(query, &[&user.id]).await?;
    match rows.get(0) {
        Some(row) => {
            let max: i32 = row.get(0);
            Ok(max + 1)
        },
        None => Ok(1)
    }
}

pub async fn get_directory(pool: &Pool, user: DbUser, ordinal: i32) -> Result<DownloadDirectory, DbError> {
    let connection = pool.get().await?;
    let query = "SELECT id, user_id, alias, path, ordinal FROM dirs WHERE user_id=$1 AND ordinal=$2;";
    let rows = connection.query(query, &[&user.id, &ordinal]).await?;
    let row = rows.get(0).ok_or(DbError::from("Directory not found"))?;
    Ok(DownloadDirectory::from_row(&row))
}

pub async fn get_directories(pool: &Pool, user: DbUser) -> Result<Vec<DownloadDirectory>, DbError> {
    let connection = pool.get().await?;
    let query = "SELECT id, user_id, alias, path, ordinal FROM dirs WHERE user_id=$1;";
    let rows:Vec<Row> = connection.query(query, &[&user.id]).await?;
    Ok(rows.iter().map(DownloadDirectory::from_row).collect())
}

pub async fn delete_directory(pool: &Pool, user: DbUser, ordinal: i32) -> Result<(), DbError> {
    let connection = pool.get().await?;
    let query = "DELETE dirs WHERE user_id=$1 AND ordinal=$2;";
    connection.execute(query, &[&user.id, &ordinal]).await?;
    Ok(())
}

pub async fn add_task(pool: &Pool, user: DbUser, server_id: &Uuid, magnet: ShortMagnet, directory: &Uuid) -> Result<DownloadTask, DbError> {
    let connection = pool.get().await?;
    let query = "INSERT INTO tasks(id, user_id, server_id, magnet, directory, status) VALUES($1,$2,$3,$4,$5,$6);";
    let task_id = Uuid::new_v4();
    connection.query(query, &[&task_id.to_string(), &user.id, &server_id.to_string(), &String::from(magnet), &directory.to_string(), &TaskStatus::Created]).await?;
    get_task_by_id(pool, &task_id).await
}

pub(crate) async fn get_task_by_id(pool: &Pool, id: &Uuid) -> Result<DownloadTask, DbError> {
    let connection = pool.get().await?;
    let query = "SELECT id, user_id, server_id, magnet, directory, status,description FROM tasks WHERE id=$1;";
    let rows = connection.query(query, &[&id.to_string()]).await?;
    let row = rows.get(0).unwrap();
    Ok(DownloadTask::from_row(&row))
}

impl DownloadTask {
    fn from_row(row: &Row) -> Self {
        DownloadTask {
            id: Uuid::parse_str(row.get(0)).expect("Uuid was generated by the system but failed to parse"),
            user_id: row.get(1),
            server_id: Uuid::parse_str(row.get(2)).expect("Uuid was generated by the system but failed to parse"),
            magnet: row.get(3),
            status: row.get(4),
            description: row.get(5),
        }
    }
}

pub async fn update_task_status(pool: &Pool, user: DbUser, id: &Uuid, status: TaskStatus) -> Result<DownloadTask, DbError> {
    let connection = pool.get().await?;
    let query = "UPDATE tasks SET status=$1 WHERE id=$2 AND user_id=$3;";
    connection.execute(query, &[&status, &id.to_string(), &user.id]).await?;
    get_task_by_id(pool, id).await
}

pub async fn update_task_status_description(pool: &Pool, user: DbUser, id: &Uuid, status: TaskStatus, description: &String) -> Result<DownloadTask, DbError> {
    let connection = pool.get().await?;
    let query = "UPDATE tasks SET status=$1, description=$2 WHERE id=$3 AND user_id=$4;";
    connection.execute(query, &[&status, &description, &id.to_string(), &user.id]).await?;
    get_task_by_id(pool, id).await
}